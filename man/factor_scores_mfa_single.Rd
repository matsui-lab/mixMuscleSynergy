% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rotation.R
\name{factor_scores_mfa_single}
\alias{factor_scores_mfa_single}
\title{Compute Factor Scores for a Single Subject in MFA}
\usage{
factor_scores_mfa_single(X, mu, Lambda, Psi)
}
\arguments{
\item{X}{A \code{(T x M)} data matrix for one subject/time-series.}

\item{mu}{A length-\code{M} mean vector for the cluster.}

\item{Lambda}{An \code{(M x r)} factor loading matrix for the cluster.}

\item{Psi}{An \code{(M x M)} diagonal covariance matrix (unique variances).}
}
\value{
A \code{(T x r)} matrix of factor scores \code{Z_i(t)}, where \code{t = 1..T}.
}
\description{
Given a single subject's data \code{X} and the cluster's parameters
(\code{mu, Lambda, Psi}), this function computes the posterior factor scores
(of size \code{T x r}) in a standard Factor Analysis approach.
}
\details{
We use the standard formula for Factor Analysis posterior means:
\deqn{
  \mathbf{Z}_i(t) = \left( \mathbf{I}_r + \Lambda^\top \Psi^{-1} \Lambda \right)^{-1}
  \Lambda^\top \Psi^{-1} \left[\mathbf{x}_i(t) - \mu\right].
}
The code is implemented in a vectorized manner. If \eqn{r = \mathrm{ncol}(\Lambda)},
then the output dimension is \code{(T x r)}.
}
\examples{
\dontrun{
X_i <- list_of_data[[i]]  # (T x M)
# from model$mu[[k]], model$Lambda[[k]], model$Psi[[k]]
Z_i <- factor_scores_mfa_single(X_i, mu_k, Lambda_k, Psi_k)
dim(Z_i)  # (T x r)
}

}
